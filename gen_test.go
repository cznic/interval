// Copyright (c) 2015 The Interval Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package interval

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"sort"
	"strconv"
	"strings"
	"testing"
)

var (
	_ Interface = (*interval)(nil)

	classes = []Class{
		Unbounded,
		Empty,
		Degenerate,

		Open,
		Closed,
		LeftOpen,
		LeftClosed,

		LeftBoundedOpen,
		LeftBoundedClosed,
		RightBoundedOpen,
		RightBoundedClosed,
	}

	gen = flag.Bool("gen", false, "")
)

func lclass(c Class) string { s := c.String(); return strings.ToLower(s[:1]) + s[1:] }

func cmp(x, y int) int {
	if x < y {
		return -1
	}

	if x == y {
		return 0
	}

	return 1
}

type interval struct {
	cls Class
	a   int
	b   int
}

func (i *interval) Class() Class                  { return i.cls }
func (i *interval) Clone() Interface              { c := *i; return &c }
func (i *interval) CompareAA(other Interface) int { return cmp(i.a, other.(*interval).a) }
func (i *interval) CompareAB(other Interface) int { return cmp(i.a, other.(*interval).b) }
func (i *interval) CompareBB(other Interface) int { return cmp(i.b, other.(*interval).b) }
func (i *interval) SetAB()                        { i.a = i.b }
func (i *interval) SetB(other Interface)          { i.b = other.(*interval).b }
func (i *interval) SetBA(other Interface)         { i.b = other.(*interval).a }
func (i *interval) SetClass(c Class)              { i.cls = c }
func (i *interval) String() string                { return fmt.Sprintf("{%v %v %v}", i.Class(), i.a, i.b) }

func (i *interval) hasA() bool {
	switch i.Class() {
	case Degenerate, Open, Closed, LeftOpen, LeftClosed, LeftBoundedOpen, LeftBoundedClosed:
		return true
	default:
		return false
	}
}

func (i *interval) hasB() bool {
	switch i.Class() {
	case Open, Closed, LeftOpen, LeftClosed, RightBoundedOpen, RightBoundedClosed:
		return true
	default:
		return false
	}
}

func (i *interval) has(x int) bool {
	switch i.Class() {
	case Unbounded:
		return true
	case Empty:
		return false
	case Degenerate:
		return i.a == x
	case Open:
		return x > i.a && x < i.b
	case Closed:
		return x >= i.a && x <= i.b
	case LeftClosed:
		return x >= i.a && x < i.b
	case LeftOpen:
		return x > i.a && x <= i.b
	case LeftBoundedOpen:
		return x > i.a
	case LeftBoundedClosed:
		return x >= i.a
	case RightBoundedOpen:
		return x < i.b
	case RightBoundedClosed:
		return x <= i.b
	default:
		panic("internal error")
	}
}

func (i *interval) includesA() bool {
	switch i.cls {
	case Degenerate, Closed, LeftClosed, LeftBoundedClosed:
		return true
	default:
		return false
	}
}

func (i *interval) includesB() bool {
	switch i.cls {
	case Closed, LeftOpen, RightBoundedClosed:
		return true
	default:
		return false
	}
}

//go:generate stringer -type Class
//go:generate go test gen_test.go interval.go class_string.go -run Gen -gen
func TestGen(t *testing.T) {
	const prolog = `// generated by go generate; DO NOT EDIT

// Copyright (c) 2015 The Interval Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package interval
`
	if !*gen {
		return
	}

	buf := bytes.NewBuffer(nil)
	w := func(format string, arg ...interface{}) {
		fmt.Fprintf(buf, format, arg...)
	}

	w(prolog)
	genIntersection(w)
	genUnion(w)
	src, err := format.Source(buf.Bytes())
	if err != nil {
		t.Logf("%s", buf.Bytes())
		t.Fatal(err)
	}

	if err := ioutil.WriteFile("gen.go", src, 0666); err != nil {
		t.Fatal(err)
	}
}

func genIntersection(w func(string, ...interface{})) {
	w(`// Intersection returns the intersection of x and y.
func Intersection(x, y Interface) Interface {
`)
	w("x, y, h := hash(x, y)\n")
	w("switch h {\n")
	m := deriveRules(analyzeIntersection)
	var a []string
	for k := range m {
		a = append(a, k)
	}
	sort.Strings(a)
	for _, s := range a {
		if s == "{}" {
			continue
		}

		w("case")
		for i, k := range m[s] {
			switch i {
			case 0:
				w(" ")
			default:
				w(", ")
			}
			w("%d", k.hash())
		}
		w(":\n")
		genResult(s, w)
	}
	w("}\n")
	w(`return setClass(x.Clone(), Empty)
}
`)
}

func genUnion(w func(string, ...interface{})) {
	w(`// Union returns the union of x and y. If the union is not an interval, nil is
// returned instead. The union is not an interval if it is a disjoint set.
func Union(x, y Interface) Interface {
`)
	w("x, y, h := hash(x, y)\n")
	w("switch h {\n")
	m := deriveRules(analyzeUnion)
	var a []string
	for k := range m {
		a = append(a, k)
	}
	sort.Strings(a)
	for _, s := range a {
		if s == "{}" {
			continue
		}

		w("case")
		for i, k := range m[s] {
			switch i {
			case 0:
				w(" ")
			default:
				w(", ")
			}
			w("%d", k.hash())
		}
		w(":\n")
		if s == "" {
			w("return nil\n")
			continue
		}

		genResult(s, w)
	}
	w("}\n")
	w(`return setClass(x.Clone(), Empty)
}
`)
}

func genResult(s string, w func(string, ...interface{})) {
	a := strings.Split(s, ", ")
	switch a[0] {
	case "inf":
		switch a[1] {
		case "inf":
			w("return setClass(x.Clone(), Unbounded)\n")
		case "[XA":
			w("return setClass(setBA(x.Clone(), x), RightBoundedClosed)\n")
		case "(XB":
			w("return setClass(x.Clone(), RightBoundedOpen)\n")
		case "[XB":
			w("return setClass(x.Clone(), RightBoundedClosed)\n")
		case "(YB":
			w("return setClass(y.Clone(), RightBoundedOpen)\n")
		case "[YB":
			w("return setClass(y.Clone(), RightBoundedClosed)\n")
		default:
			panic("internal error")
		}
	case "(XA":
		switch a[1] {
		case "inf":
			w("return setClass(x.Clone(), LeftBoundedOpen)\n")
		case "(XB":
			w("return setClass(x.Clone(), Open)\n")
		case "[XB":
			w("return setClass(x.Clone(), LeftOpen)\n")
		case "(YB":
			w("return setClass(setB(x.Clone(), y), Open)\n")
		case "[YB":
			w("return setClass(setB(x.Clone(), y), LeftOpen)\n")
		default:
			panic("internal error")
		}
	case "[XA":
		switch a[1] {
		case "inf":
			w("return setClass(x.Clone(), LeftBoundedClosed)\n")
		case "[XA":
			w("return setClass(x.Clone(), Degenerate)\n")
		case "(XB":
			w("return setClass(x.Clone(), LeftClosed)\n")
		case "[XB":
			w("return setClass(x.Clone(), Closed)\n")
		case "(YB":
			w("return setClass(setB(x.Clone(), y), LeftClosed)\n")
		case "[YB":
			w("return setClass(setB(x.Clone(), y), Closed)\n")
		default:
			panic("internal error")
		}
	case "[XB":
		switch a[1] {
		case "[XB":
			w("return setClass(setAB(x.Clone()), Degenerate)\n")
		default:
			panic("internal error")
		}
	case "(YA":
		switch a[1] {
		case "inf":
			w("return setClass(y.Clone(), LeftBoundedOpen)\n")
		case "[XA":
			w("return setClass(setBA(y.Clone(), x), LeftOpen)\n")
		case "(XB":
			w("return setClass(setB(y.Clone(), x), Open)\n")
		case "[XB":
			w("return setClass(setB(y.Clone(), x), LeftOpen)\n")
		case "(YB":
			w("return setClass(y.Clone(), Open)\n")
		case "[YB":
			w("return setClass(y.Clone(), LeftOpen)\n")
		default:
			panic("internal error")
		}
	case "[YA":
		switch a[1] {
		case "inf":
			w("return setClass(y.Clone(), LeftBoundedClosed)\n")
		case "[XA":
			w("return setClass(setBA(y.Clone(), x), Closed)\n")
		case "(XB":
			w("return setClass(setB(y.Clone(), x), LeftClosed)\n")
		case "[XB":
			w("return setClass(setB(y.Clone(), x), Closed)\n")
		case "[YA":
			w("return setClass(y.Clone(), Degenerate)\n")
		case "(YB":
			w("return setClass(y.Clone(), LeftClosed)\n")
		case "[YB":
			w("return setClass(y.Clone(), Closed)\n")
		default:
			panic("internal error")
		}
	default:
		panic("internal error")
	}
}

const (
	negInf = -60
	posInf = 60
)

func samples(c Class) (r []*interval) {
	switch c {
	case Unbounded, Empty:
		r = append(r, &interval{cls: c})
	case Degenerate, LeftBoundedOpen, LeftBoundedClosed:
		for a := negInf + 10; a <= posInf-10; a += 5 {
			r = append(r, &interval{cls: c, a: a})
		}
	case Open, Closed, LeftOpen, LeftClosed:
		for a := negInf + 10; a <= posInf-10; a += 5 {
			for b := a + 20; b <= posInf-10; b += 5 {
				r = append(r, &interval{cls: c, a: a, b: b})
			}
		}
	case RightBoundedOpen, RightBoundedClosed:
		for b := negInf + 10; b <= posInf-10; b += 10 {
			r = append(r, &interval{cls: c, b: b})
		}
	default:
		panic("internal error")
	}
	return r
}

func abs(n int) int {
	if n >= 0 {
		return n
	}

	return -n
}

type key struct {
	xc   Class
	yc   Class
	xaya string
	xayb string
	xbya string
	xbyb string
}

// -- 00
// -1 01
//  0 10
//  1 11
func (k *key) enc(s string) int {
	switch s {
	case "":
		return 0
	case "-1":
		return 1
	case "0":
		return 2
	case "1":
		return 3
	default:
		panic("internal error")
	}
}

func (k *key) String() string {
	return fmt.Sprintf("{%v %v %q %q %q %q}", k.xc, k.yc, k.xaya, k.xayb, k.xbya, k.xbyb)
}

func (k *key) hash() int {
	if k.xc > k.yc {
		panic("internal error")
	}

	return (int(k.xc)*int(nClasses)+int(k.yc))<<8 | k.enc(k.xbyb)<<6 | k.enc(k.xbya)<<4 | k.enc(k.xayb)<<2 | k.enc(k.xaya)
}

func deriveRules(f func(Class, Class) map[key]string) map[string][]key {
	m := map[string][]key{}
	for _, xc := range classes {
		for _, yc := range classes[xc:] {
			for k, s := range f(xc, yc) {
				k.xc = xc
				k.yc = yc
				m[s] = append(m[s], k)
			}
		}
	}
	for s, ks := range m {
		n := map[string]key{}
		for _, k := range ks {
			n[k.String()] = k
		}
		var a []string
		for s := range n {
			a = append(a, s)
		}
		sort.Strings(a)
		var nks []key
		for _, s := range a {
			nks = append(nks, n[s])
		}
		m[s] = nks
	}
	return m
}

func analyzeIntersection(xc, yc Class) map[key]string {
	m := map[key][]string{}
	for _, x := range samples(xc) {
		for _, y := range samples(yc) {
			if x.hasA() && y.hasA() && x.a != y.a && abs(x.a-y.a) <= 10 ||
				x.hasA() && y.hasB() && x.a != y.b && abs(x.a-y.b) <= 10 ||
				x.hasB() && y.hasA() && x.b != y.a && abs(x.b-y.a) <= 10 ||
				x.hasB() && y.hasB() && x.b != y.b && abs(x.b-y.b) <= 10 {
				continue
			}
			var from, to string
			for n := negInf; n <= posInf; n += 5 {
				if x.has(n) && y.has(n) {
					var s string
					switch {
					case n == negInf, n == posInf:
						s = "inf"
					case x.hasA() && x.includesA() && n == x.a:
						s = "[XA"
					case x.hasA() && !x.includesA() && n == x.a+5:
						s = "(XA"
					case x.hasB() && !x.includesB() && n == x.b-5:
						s = "(XB"
					case x.hasB() && x.includesB() && n == x.b:
						s = "[XB"
					case y.hasA() && y.includesA() && n == y.a:
						s = "[YA"
					case y.hasA() && !y.includesA() && n == y.a+5:
						s = "(YA"
					case y.hasB() && !y.includesB() && n == y.b-5:
						s = "(YB"
					case y.hasB() && y.includesB() && n == y.b:
						s = "[YB"
					}
					if from == "" {
						from = s
					}
					to = s
				}
			}
			var k key
			if x.hasA() && y.hasA() {
				k.xaya = strconv.Itoa(cmp(x.a, y.a))
			}
			if x.hasA() && y.hasB() {
				k.xayb = strconv.Itoa(cmp(x.a, y.b))
			}
			if x.hasB() && y.hasA() {
				k.xbya = strconv.Itoa(cmp(x.b, y.a))
			}
			if x.hasB() && y.hasB() {
				k.xbyb = strconv.Itoa(cmp(x.b, y.b))
			}
			if from != "" {
				m[k] = append(m[k], from+", "+to)
				continue
			}

			m[k] = append(m[k], "{}")
		}
	}
	r := map[key]string{}
	for k, v := range m {
		v0 := v[0]
		for _, v := range v[1:] {
			if v != v0 {
				panic("internal error")
			}
		}
		r[k] = v0
	}
	return r
}

func analyzeUnion(xc, yc Class) map[key]string {
	const (
		initial = iota
		in
		after
	)
	m := map[key][]string{}
	for _, x := range samples(xc) {
		for _, y := range samples(yc) {
			if x.hasA() && y.hasA() && x.a != y.a && abs(x.a-y.a) <= 10 ||
				x.hasA() && y.hasB() && x.a != y.b && abs(x.a-y.b) <= 10 ||
				x.hasB() && y.hasA() && x.b != y.a && abs(x.b-y.a) <= 10 ||
				x.hasB() && y.hasB() && x.b != y.b && abs(x.b-y.b) <= 10 {
				continue
			}
			var from, to string
			ok := true
			var state int
		loop:
			for n := negInf; n <= posInf; n += 5 {
				if x.has(n) || y.has(n) {
					switch state {
					case initial:
						state = in
					case in:
						// nop
					case after:
						// Union is not an interval
						from = ""
						to = ""
						ok = false
						break loop
					}
					var s string
					switch {
					case n == negInf, n == posInf:
						s = "inf"
					case x.hasA() && x.includesA() && n == x.a:
						s = "[XA"
					case x.hasA() && !x.includesA() && n == x.a+5:
						s = "(XA"
					case x.hasB() && !x.includesB() && n == x.b-5:
						s = "(XB"
					case x.hasB() && x.includesB() && n == x.b:
						s = "[XB"
					case y.hasA() && y.includesA() && n == y.a:
						s = "[YA"
					case y.hasA() && !y.includesA() && n == y.a+5:
						s = "(YA"
					case y.hasB() && !y.includesB() && n == y.b-5:
						s = "(YB"
					case y.hasB() && y.includesB() && n == y.b:
						s = "[YB"
					}
					if from == "" {
						from = s
					}
					to = s
					continue
				}

				switch state {
				case initial:
					// nop
				case in:
					state = after
				case after:
					// nop
				}

			}
			var k key
			if x.hasA() && y.hasA() {
				k.xaya = strconv.Itoa(cmp(x.a, y.a))
			}
			if x.hasA() && y.hasB() {
				k.xayb = strconv.Itoa(cmp(x.a, y.b))
			}
			if x.hasB() && y.hasA() {
				k.xbya = strconv.Itoa(cmp(x.b, y.a))
			}
			if x.hasB() && y.hasB() {
				k.xbyb = strconv.Itoa(cmp(x.b, y.b))
			}
			if from != "" {
				m[k] = append(m[k], from+", "+to)
				continue
			}

			if ok {
				m[k] = append(m[k], "{}")
				continue
			}

			m[k] = append(m[k], "")
		}
	}
	r := map[key]string{}
	for k, v := range m {
		v0 := v[0]
		for _, v := range v[1:] {
			if v != v0 {
				panic("internal error")
			}
		}
		r[k] = v0
	}
	return r
}
